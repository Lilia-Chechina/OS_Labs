#include <stdio.h>      // для стандартного ввода-вывода (printf, perror и т.д.)
#include <unistd.h>     // для системных вызовов (read, write, pipe, fork, execl и т.д.)
#include <stdlib.h>     // для функций общего назначения (exit, malloc, atoi и т.д.)
#include <sys/types.h>  // для определения различных типов данных (pid_t и т.д.)
#include <sys/wait.h>   // для управления процессами (wait)
#include <fcntl.h>      // для работы с файловыми дескрипторами (open, O_RDONLY и т.д.)
#include <string.h>     // для работы со строками (strlen, strcmp и т.д.)
#include <stdbool.h>    // для использования типа данных bool (true, false)

/* Этот файл отвечает за создание дочернего процесса и перенаправление 
ввода/вывода между родительским и дочерним процессами. */
void check_error(bool expression, char* message) {  // f-ия проверяет, произошла ли ошибка или нет
// message - указание об ошибке
    if (expression) {  // если истинно
        write(STDOUT_FILENO, message, strlen(message) * sizeof(char));  // <unistd>
        write(STDOUT_FILENO, "\n", 1);
        exit(-1);  // чтоб наверняка всю программу отключить
    }
}

int main (int argc, char* argv[]) {
    pid_t pid;  // pid для идентификатора процесса 
    int pipe_1[2];  // массив pipe_1 для дескрипторов канала:0,1,2
    if (pipe(pipe_1) == -1) {  // создание неименованного канала, если ошибка, то сообщение о ней и завершение выполнения
        perror("pipe");
        _exit(EXIT_FAILURE);  // немедленное завершение процесса
    }
    if (argc != 2) {  // проверка на то, что передано 2 аргумента: если их <, то ошибка
        // имя аргумента и текстовый файл
        write(1, "Ошибка: неправильно переданы аргументы!\n", 20);
        return 1; // exit(EXIT_FAILURE);
    }
    int fd = open(argv[1], O_RDONLY);  // открываем файл на чтение идентификатор из ftl
    check_error(fd == -1, "Ошибка: файл не открывается!");  // если файл не открывается, то вызываем эту f-ию
    // Ниже идёт создание дочернего процесса
    pid = fork();
    if (pid == -1) { // это если ошибка
        perror("fork");
        return 1;
}
    else if (pid == 0) {  // pid возвращает 0, если в дочернем процессе, где был создан и идентификатор в родительском
        close (pipe_1[0]);  //  В дочернем процессе закрывается конец канала pipe_1[0], который предназначен для чтения.
        // Это делается для того, чтобы избежать ненужного чтения в дочернем процессе.
        /*Дочерний процесс не будет читать из канала; он будет писать в pipe_1[1], поэтому закрытие pipe_1[0] помогает 
        избежать утечек дескрипторов и обеспечивает, что при записи в канал будет правильно завершено чтение в родительском процессе.*/
        check_error(dup2(fd, STDIN_FILENO) < 0, "Ошибка дублирования!");  // если вернул < 0, то ошибка
        dup2(pipe_1[1], STDOUT_FILENO);  // перенаправляем вывод дочернего процесса в канал
        execl("./child", "/.child", NULL);  // запускаем программу child
        perror("Ошибка: execl!");
        return 1;
    }
    else {  // выполн, если находится в род процессе
        check_error((pid == -1), "Ошибка процесса!");
        close(pipe_1[1]);  // закрывает конец канала для записи
        wait(0);  // Этот вызов блокирует выполнение родительского процесса до тех пор, пока дочерний процесс не завершится.
        int result;
        char answer[50];
        //  цикл выполняется, пока read() читает данные из канала pipe_1[0].
        while ((read(pipe_1[0], &result, sizeof(int))) > 0) {
            if (result == -1) {
                write(STDOUT_FILENO, "Произошла какая-то ошибка...\n", 22);
                // exit(EXIT_FAILURE);
                return 1;
            }
            sprintf(answer, "%d\n", result);  // для форматирования
            check_error(write(STDOUT_FILENO, answer, strlen(answer)) == -1, "Ошибка вывод!\n");
            check_error(write(STDOUT_FILENO, "\n", 1) == -1, "Ошибка вывода!\n");
        }
    }
    return 0;
}
